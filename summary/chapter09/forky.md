# 01 개방-폐쇄 원칙

개방-폐쇄 원칙(Open-Closed Principle, OCP): 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려있어야 하고, 수정에 대해서는 닫혀 있어야 한다

- 확장에 대해 열려있다: 동작을 추가해서 기능을 확장할 수 있다
- 수정에 대해 닫혀있다: 기존의 코드를 수정하지 않고도 동작을 추가, 변경할 수 있다

## 컴파일타임 의존성을 고정시키고 런타임의존성을 변경하라

런타임 의존성과 컴파일타임 의존성이 서로 다른 유연한 설계

- 컴파일타임 의존성 수정 X - 수정에 닫혀있다
- 런타임 의존성을 변경 - 확장에 열려있다

## 추상화가 핵심이다

모든 요소가 추상화에 의존해야 한다

- 추상화를 통해 문맥이 바뀌어도 변하지 않는 부분만 남기고 문맥에 따라 변하는 부분은 생략
- 변경되지 않을 부분을 신중히 결정하여 올바른 추상화를 선택하라

# 02 생성 사용 분리

생성과 사용을 분리(separating use from creation)

- 시작 단계(객체 생성, 의존성 연결) - 실행 단계를 분리해야 한다
- 현재의 컨텍스트에 대한 결정권을 가진 클라이언트로 컨텍스트 지식을 이동하여 클라이언트 독립적인 객체를 만들어라

## FACTORY추가하기

FACTORY: 객체 생성에 특화된 객체

- 객체 생성에 대한 지식을 클라이언트로부터 격리

## 순수한 가공물에게 책임 할당하기

시스템 분해하는 방식

- 표현적 분해: 도메인에 존재하는 사물 또는 개념을 표현하는 객체들로 시스템 분해
- 행위적 분해: 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임 할당
    - PURE FABRICATON(순수한 가공물): 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적 객체

인공적인 객체와 도메인 객체를 조화시켜라

- 도시의 본질은 자연과 인간에게 있지만 도시의 대부분은 생활 편리를 위한 인공물로 채워져 있다
- 도메인 추상화 기반 설계 + 품질 균형을 위해 필요한 인공 객체
    - 먼저 도메인의 본질적 개념을 표현하는 추상화로 구축 → 필요할 때 주저말고 인공적인 객체 창조
    - 정보 전문가 패턴의 대안으로 사용할 수 있다(객체가 필요한 정보를 가졌지만 해당 책임 할당 시 낮은 응집도, 높은 결합도가 된다면 가공의 객체에게 책임 할당)

# 03 의존성 주입

의존성 주입(Dependency Injection): 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스 생성, 전달하여 필요한 의존성 해결하는 방법

- 생성자 주입: 생성 시점에 생성자로 의존성 해결
- setter 주입: 생성 후 setter 메서드로 의존성 해결
- 메서드 주입: 메서드 실행 시 인자로 의존성 해결

## 숨겨진 의존성은 나쁘다

SERVICE LOCATOR 패턴: 의존성 해결할 객체들을 보관하는 저장소(SERVICE LOCATOR)가 있고, 객체가 SERVICE LOCATOR에게 의존성 해결을 요청

→ 퍼블릭 인터페이스에 의존성이 드러나지 않는다

SERVICE LOCATOR 패턴의 문제

- 문제점 발견 시점을 컴파일타임이 아닌 런타임으로 미룬다
- 단위 테스트 시 테스트 케이스에 걸쳐 상태가 공유되어 고립성 원칙 위반한다
- 의존성 이해를 위해서는 내부 구현을 이해해야 하므로 캡슐화 위반한다
- 의존성 대상 설정 시점과 의존성 해결 시점이 멀리 떨어진다

> 인스턴스 변수 가시성을 숨겼다고 해서 캡슐화가 아니다. 인터페이스만으로 클래스의 올바른 사용법을 알 수 없다면 캡슐화는 무너진것이다.
> 

문제는 숨겨진 의존성이다

- 명시적인 의존성이 숨겨진 의존성보다 좋다

# 04 의존성 역전 법칙

## 추상화와 의존성 역전

상위 수준 클래스: 협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 클래스

- 상위 수준의 클래스는 하위 수준의 클래스에 의존해서는 안된다

의존성 역전 원칙(Dependency Inversion Principle, DIP)

- 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 둘 다 추상화에 의존해야 한다.
- 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.
    - 구체 클래스는 의존성의 시적점이어야 하며, 의존성의 목적지가 되면 안된다

## 의존성 역전 원칙과 패키지

인터페이스 소유권을 서버가 아닌 클라이언트 패키지에 위치시켜라

- 상위 수준 모듈과 하위 수준 모듈 모두 추상화에 의존
- 인터페이스는 상위 수준 모듈에 포함

# 05 유연성에 대한 조언

## 유연한 설계는 유연성이 필요할 때만 옳다

유연한 설계는 복잡하다

- 설계의 미덕은 단순함과 명확함
- 아직 일어나지 않은 변경은 변경이 아니다
- 유연함은 단순성과 명확성의 희생 위에서 자라난다
    - 유연한 설계를 단순, 명확하게 만드는 유일한 방법은 긴밀한 커뮤니케이션 뿐
- 유연성은 코드 독자가 복잡함을 수용할 수 있을 때만 가치있다

## 협력과 책임이 중요하다

- 다양한 컨텍스트에서 재사용될 필요 없는 협력 → 설계를 유연하게 만들 당위성 X
- 객체 생성 방식에 대한 결정은 모든 책임이 자리 잡은 후 마지막에
    - 책임 관점에서 객체 간 균형이 잡히지 않은 상태에서 객체 생성 책임을 결정하면 하부의 특정한 메커니즘에 종속된 설계가 될 가능성이 높다
    - 객체가 이미 존재하는 것처럼 객체 간의 관계에 신경쓰라
