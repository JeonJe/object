# 유연한 설계

## 01 개방 - 폐쇄 원칙 (OCP)
확장에는 열려있고, 수정에는 닫혀 있다. 

런타임 의존성, 컴파일 의존성에 대한 이야기다. 
컴파일 타임에 의존성을 유지하면서, 런타임 의존성을 쉽게 변경할 수 있는 구조.

### 추상화가 핵심이다
추상화 -> 문맥이 바뀌더라도 변하지 않는 부분만 남음. 

추상화에 대해서만 의존하도록 함으로써 OCP를 지킨다. 

## 02 생성 사용 분리
결합도가 높을수록 OCP를 지키기 어려워진다.
객체 생성은 언젠가 해야하지만, 부적절한 곳에서 객체 생성하는 것이 문제다. 

사용과 생성을 분리해야 한다.

### FACTORY 추가하기 - 순수한 가공물
객체 생성만 전담하는 책임을 가진 FACTORY를 만들고 client도 이걸 사용하면 된다.
전체적인 결합도를 낮추고, 재사용성을 높이기 위해서 도메인 모델과는 상관없는 전적으로 기술적인 객체를 생성한 것이다.

## 03 의존성 주입
외부에서 객체를 생성해서 전달해 주는 것.

setter 주입, 생성자 주입, 정적 팩터리 메서드 

### 숨겨진 의존성은 나쁘다. 
service locator 메서드는 의존성을 숨겨서 지양된다.
너무 깊이 들어가기 싫어서 사용할 순 있다,

## 04 의존성 역전 원칙(DIP)
### 추상화와 의존성 역전
협력의 중요한 의사결정, 비즈니스 본질을 가지고 있는 것은 상위 클래스이다. 
하위에 의존성을 가지고 있으면 하위가 바뀌면서 상위 메인 로직이 흔들린다.

구체클래스는 의존성의 시작점이어야하지, 목적지가 되서는 안된다.
- 상위 수준, 하위 수준 모두 추상화에 의존해야한다.
- 추상화는 구체적인 사항에 의존하면 안된다. 구체적인 사항은 추상화에 의존해야 한다.

### 의존성 역전 원칙과 패키지


## 05 유연성에 대한 조언
### 유연한 설계는 유연성이 필요할 때만 옳다.