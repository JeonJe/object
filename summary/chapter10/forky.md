코드 재사용 방법

- 상속: 클래스 안에 정의된 인스턴스 변수, 메서드를 자동으로 새 클래스에 추가
- 합성: 새 클래스의 인스턴스 안에 기존 클래스 인스턴스 포함

# 01 상속과 중복 코드

## DRY 원칙

Don’t Repeat Yourself

- 동일한 지식을 중복하지 말라
    - Once and Only Once
    - Single-Point Control
- 중복의 판단 기준은 변경
    - 요구사항 변경 시 두 코드를 함께 수정 → 중복
    - 코드 모양이 판단 기준이 아니다

## 중복과 변경

중복 코드를 수정하면 새 중복 코드가 추가된다

- 일관성 무너질 위험성
- 중복 코드 많을 수록 버그 증가, 변경 속도 저하

## 상속을 이용해서 중복 코드 제거하기

상속은 결합도를 높인다

- 상속을 위해 설계되지 않은 클래스를 재사용을 위하 상속할 경우, 상속 계층 사이에 직관과 어긋나는 가정들이 세워질 수 있다
- 상속 사용을 위해서는 부모 클래스를 정확히 이해해야 한다
    - 결합도 = 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지
    - 부모 - 자식 간 강한 결합

## 강하게 결합된 Phone과 NightlyDiscountPhone

> 자식 클래스에서 부모 클래스 메서드 직접 호출(super)하는 경우, 두 클래스는 강하게 결합
> 
- super 호출 제거하라

# 02 취약한 기반 클래스 문제

취약한 기반 클래스 문제(Fragile Base Class Problem, Brittle Base Class Problem)

- 상속의 높은 결합도로 인해 부모 클래스 변경이 자식 클래스에 영향 미치는 현상

취약한 기반 클래스 문제는 캡슐화를 약화시킨다

- 캡슐화를 통해 변경을 통제해야 하는데, 부모 클래스 구현을 바꾸면 모든 자식 클래스 받기 쉬움

## 불필요한 인터페이스 상속 문제

> 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다
> 

코드 재사용을 위해 불필요한 오퍼레이션이 섞이면 안된다

- 인터페이스는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 만들어야 한다

## 메서드 오버라이딩의 오작용 문제

> 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다
> 

Joshua Bloch “상속을 위해 설계하고 문서화한 클래스가 아니면 상속을 금지시켜야 한다”

- 오버라이딩 파급 효과 문서화하라
- how 설명하면 안된다는 통념 어기는 것 맞다, 상속이 캡슐화를 위반하기 때문

상속은 코드 재사용을 위해 캡슐화를 희생한다

## 부모 클래스와 자식 클래스의 동시 수정 문제

> 클래스를 상속하면 결합도로 인해 부모-자식 클래스 구현을 영원히 변경하지 않거나, 부모-자식 클래스를 동시에 변경하거나 둘 중 하나를 선택해야 한다
> 

부모-자식 클래스 강결합 → 함께 수정해야 하는 상황 빈번

- 부모 메서드 오버라이딩 하지 않아도, 불필요한 인터페이스 상속받지 않아도

# 03 Phone 다시 살펴보기

취약한 기반 클래스 문제 완화

## 추상화에 의존하자

부모-자식 모두 추상화에 의존하도록 수정

- 자식이 부모 클래스의 구현이 아닌 추상화를 의존

코드 중복 제거를 위한 상속 도입 시 따를 수 있는 원칙

- 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출해서 동일한 형태로 보이도록 만들어라
- 부모 클래스 코드를 내리지 말고 자식 클래스 코드를 올려라
    - 재사용성, 응집도 측면에서 더 나은 결과

## 차이를 메서드로 추출하라

중복 코드 안의 차이점을 별도 메서드로 추출

- 메서드 수준에서 변하는 것으로 부터 변하지 않는 것을 분리, 변하는 부분 캡슐화

## 중복 코드를 부모 클래스로 올려라

공통 메서드 → 추상 부모 클래스로 이동, 차이나는 구현 → override

- 설계가 추상화에 의존

위로 올리기 vs 아래로 내리기

- 위로 올리기 전략은 실수도 쉽게 눈에 띈다
- 아래로 내리기 전략은 작은 실수만으로도 구체 행동을 상위 클래스에 남겨놓게 된다

## 추상화가 핵심이다

클래스들이 추상화에 의존할 때의 장점

- 단일 책임 원칙 준수
    - 각 클래스 변경 이유 하나
- 낮은 결합도
    - 시그니처 변경 없으면 구현 변경 영향 X
- 의존성 역전 원칙 준수
    - 세부 사항이 추상에 의존
- 개방-폐쇄 원칙 준수
    - 새로운 구체 맥락 추가 시 새로운 자식 클래스 추가만 하면 됨

상속 계층이 걸림돌 → 추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 리팩터링하라

- 차이점은 메서드로 추출, 공통 부분은 부모 클래스로 이동

## 세금 추가하기

상속으로 인한 클래스 사이의 결합을 피할 수 없다

- 추상화에 의존해도 인스턴스 변수 목록 변경은 자식 클래스 초기화 로직에 영향을 준다

그래도 핵심 로직의 중복을 막아라

- 객체 생성 로직 변경에 대응할 방법은 많다
- 핵심 로직은 한 곳에 모아놓고 조심스럽게 캡슐화해야 한다

# 04 차이에 의한 프로그래밍

차이에 의한 프로그래밍(programming by difference): 기존 코드와 다른 부분만 추가하여 기능 확장하는 방법

- 중복 코드 제거, 재사용이 목표
    - 코드 품질 유지하면서 코드 작성 비용 절감
- 상속 → 이미 존재하는 클래스 쉽게 재사용 → 애플리케이션의 점진적인 정의

상속 오남용은 이해하고 확장하기 어렵게 만든다

- 정말 필요할 때만 쓸 것
- 코드 재사용을 위해서라면 더 좋은 방법이 있다 (합성)
