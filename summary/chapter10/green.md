
# 10장 상속과 코드 재사용

# 개요

객체지향에서는 상속과 합성으로 코드를 재사용 할 수 있다

- **합성**은 **새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함**시키는 방법

# 1. 상속과 중복 코드

- 중복 코드는 변경을 방해한다. 코드는 언젠가 변하기 마련인데 중복 코드는 코드를 변경하는 일을 몇 배 더 힘들게 만든다.
- 중복 여부를 판단하는 기준은 변경이다. 요구사항이 변경 되었을 때 두 코드가 함께 수정되어야 한다면 중복이다.

## DRY 원칙

- Don’t Repeat Yourself
- 핵심은 코드 안에 중복이 존재하면 안된다.

## 타입 코드 사용하기

두 클래스 사이의 중복 코드를 제거하는 방법 중 하나는 클래스를 하나로 합치는 것이다. 예로 요금제를 구분하는 `타입 코드(enum)`을 추가하고, 타입 코드의 값에 따라 로직을 분기 시킬 수 있다. 다만 이렇게 코드를 구현할 경우 **낮은 응집도**와 **높은 결합도**를 갖게 된다.

## 상속을 이용해 중복코드 제거하기

이미 존재하는 유사한 클래스가 필요하면 코드를 복사하지 말고 상속하자.

```java
public class NightDiscountPhone extends Phone {
    private static final int LATE_NIGHT_HOUR = 22;

    private Money nightAmount;

    @Override
    public Money calculateFee() {
        // 부모 클래스의 calculateFee 호출
        Money result = super.calculateFee();
        Money nightlyFee = Money.zero;
        for (Call call : calls) {
            if (call.getFrom().getHours() >= LATE_NIGHT_HOUR) {
                nightlyFee = nightlyFee.plus(
                        getAmount.minus(nightAmount).times(
                                call.getDuration().getSeconds() / getSeconds().getSeconds()
                        )
                );
            }
        }
        return result.minus(nightlyFee);
    }
}
```

- 부모인 Phone을 구현하는 일반 요금제는 1개의 요금 규칙으로 구성되어있다.
- NightlyDiscountPhone으로 구현할 심야 요금제는 10시를 기준으로 2개의 요금제로 구성되어 있다.
- 상속을 잘못 사용하게 되면 코드를 이해하기 어렵고, 직관에도 어긋날 수 있다.
- 상속은 결합도를 높히고, 코드를 수정하기 어렵게 만든다

자식 클래스의 메서드 안에서 `super` 참조를 이용해 부모 클래스의 메서드를 직접 호출하는 경우 두 클래스가 강하게 결합이 된다. **super 호출을 제거할 수 있으면 제거하여 결합도를 낮추는 게 좋다.**

# 2. 취약한 기반 클래스 문제

`취약한 기반 클래스 문제` - 부모 클래스의 변경에 의해 영향 받는 현상

상속을 사용한다면 피할 수 없는 객체지향 프로그래밍의 근본적인 취약성이다.

**즉, 상속은 자식 클래스가 부모 클래스의 세부사항에 의존하기 때문에 캡슐화를 약화시키고 구현에 대한 결합도를 높히는 문제를 가지고 있다.**

## 불필요한 인터페이스 상속 문제

자바 초기 개발자들은 요소의 추가, 삭제 오퍼레이션을 제공하는 Vector를 재사용하기 위해 Stack을 Vector의 자식 클래스로 구현했다. Stack은 Last In First Out으로 동작해야하는데 **Vector의 퍼블릭 인터페이스를 사용하면 Stack의 규칙을 쉽게 위반할 수 있다.**

**즉, 상속받는 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.**

## 메소드 오버라이딩의 오작용 문제

자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 땐 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다. 만약 클래스가 상속 되기를 원한다면 상속을 위해 클래스를 설계하고 **문서화**하며 그렇지 않은 경우 상속을 금지해야한다는 주장도 있다.

## 부모 클래스와 자식 클래스의 동시 수정 문제

자식 클래스가 부모 클래스의 메서드를 오버라이딩하거나 불필요한 인터페이스를 상속받지 않더라도 부모 클래스를 수정하게 되면 자식 클래스를 함께 수정해야 할 수도 있다.

클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나 **동시에 변경**해야한다.

# 3. Phone 클래스 다시 살펴보기

취약한 기반 클래스 문제는 완전히 없앨 수 없지만 추상화로 위험을 감소 시킬 순 있다.

## 추상화에 의존하기

자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만든다.

코드 중복을 제거하기 위해 상속을 도입할 때 원칙 2가지

### 1) 두 메서드의 차이점을 메서드로 추출

메서드 추출을 통해 동일한 형태로 만들 수 있다. 즉 요금 계산이 다른 두 클래스가 있다면 요금 계산 부분을 동일한 이름을 가진 메소드로 추출한다.

### 2) 중복 코드를 부모 클래스로 올린다

모든 클래스들이 추상화에 의존하도록 만들기 위해 추상 클래스를 만들고, 공통된 부분 옮긴다. 옮길 땐 메소드부터 옮겨 꼭 필요한 인스턴스 변수만 이동시킬 수 있도록 하자. 내용에 차이가 있는 메소드는 추상 메소드로 선언한다.

## 추상화가 핵심이다

이제 추상화를 적용하면 변경의 이유가 각 클래스에게로 제한된다. 즉, 클래스는 단일 책임 원칙을 준수하고 부모와 낮은 결합도를 유지한다.

만약 상속계층이 코드를 변경하는데 걸림돌이 된다면 **추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩토링해라.**

## 의도를 드러내는 이름 선택하기

의도를 잘 나타내도록 클래스 이름을 변경한다

abstractPhone 는 `phone`으로  phone 는 `regularPhone`으로 변경한다.

## 세금 추가하기

추상 클래스에 인스턴스 변수가 추가되면 그 구현체도 인스턴스 변수가 추가되어야 한다. 자식 클래스는 자신의 인스턴스를 생성할 때 부모 클래스의 정의된 인스턴스 변수를 초기화 해야 하기 때문이다. **하지만 초기화 로직을 변경하는 것이 코드를 중복 시키는 것보단 현명한 선택이다.**

# 4. 차이에 의한 프로그래밍

`차이에 의한 프로그래밍` -  기존 코드와 다른 부분만을 추가함으로써 기능을 확장하는 방법

중복 코드를 제거하기 위해 최대한 코드를 재사용해야한다. 재사용 가능한 코드란 심각한 버그가 존재하지 않고 코드의 품질은 유지하면서 코드를 작성하는 노력과 테스트를 줄일 수 있다.

상속을 이용하면 새로운 기능을 추가하기 위해 구현하는 코드의 양을 줄일 수 있다. 하지만 상속의 오남용은 애플리케이션의 이해와 확장을 어렵게 만든다. 상속의 단점을 피하면서도 재사용을 할 수 있는 더 좋은 방법은 `합성`이다.
